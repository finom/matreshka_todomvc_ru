{
  "name": "matreshka-router",
  "version": "0.0.5",
  "description": "Router-like plugin for Matreshka.js",
  "main": "matreshka-router.js",
  "scripts": {
    "test": "gulp test",
    "coveralls": "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/matreshkajs/matreshka-router.git"
  },
  "keywords": [
    "matreshka",
    "router"
  ],
  "author": {
    "name": "Andrey Gubanov"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/matreshkajs/matreshka-router/issues"
  },
  "homepage": "https://github.com/matreshkajs/matreshka-router#readme",
  "devDependencies": {
    "babel-preset-es2015": "^6.3.13",
    "babel-preset-stage-0": "^6.3.13",
    "coveralls": "^2.11.6",
    "gulp": "^3.9.0",
    "gulp-rename": "^1.2.2",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-uglify": "^1.5.1",
    "gulp-util": "^3.0.7",
    "jasmine-core": "^2.4.1",
    "karma": "^0.13.19",
    "karma-babel-preprocessor": "^6.0.1",
    "karma-coverage": "^0.5.3",
    "karma-jasmine": "^0.3.6",
    "karma-phantomjs-launcher": "^0.2.3",
    "karma-requirejs": "^0.2.3",
    "phantomjs": "^2.1.2",
    "requirejs": "^2.1.22",
    "matreshka": "^1.7.0"
  },
  "readme": "Router-like plugin for Matreshka\n============\n\n[![Coverage Status](https://coveralls.io/repos/github/matreshkajs/matreshka-router/badge.svg?branch=master)](https://coveralls.io/github/matreshkajs/matreshka-router?branch=master) [![Build Status](https://travis-ci.org/matreshkajs/matreshka-router.svg?branch=master)](https://travis-ci.org/matreshkajs/matreshka-router) [![npm version](https://badge.fury.io/js/matreshka-router.svg)](https://badge.fury.io/js/matreshka-router)\n\n[Demo](http://output.jsbin.com/pigihe/10/#!/foo/bar/baz/)\n\n# tl;dr\n\nThe plugin turns on two-way data binding between properties and parts of ``location.hash`` hash.\n\n```js\nthis.initRouter('/a/b/c/');\nthis.a = 'foo';\nthis.b = 'bar';\nthis.c = 'baz';\n\n// makes location.hash to be #!/foo/bar/baz/\n```\n\nIf you need to use History API instead of hash, pass ``\"history\"`` as second argument.\n\n\n```js\nthis.initRouter('/a/b/c/', 'history');\n```\n\nInstalling:\n```\nnpm install --save matreshka-router\n```\n-------\n\n\n\nHow does \"traditional\" routing works? A developer defines a rule (route) and defines a function which will be called when current path fits given rule.\n\n```js\nroute(\"books/:id\", id => {\n\t// do something\n});\n```\n\n\n\nThe principle of the plugin is the following. You define which part of an URL (both [hash](https://developer.mozilla.org/ru/docs/Web/API/Window/location), and [HTML5 History](https://developer.mozilla.org/ru/docs/Web/API/History_API) are supported) need to be synchronized with given property.\n\n**Disclamer:** this way of routing may not be what you're looking for. If you need full-featured router you can use any library you want (eg. [Director](https://github.com/flatiron/director)).\n\nFor example you need to synchronize ``\"x\"`` with the first part of ``location.hash`` and ``\"y\"`` with the second.\n\n```js\nthis.initRouter(\"/x/y/\");\n```\n\nNow  when you type...\n\n```js\nthis.x = 'foo';\nthis.y = 'bar';\n```\n\n...``location.hash`` is automatically replaced by ``#!/foo/bar/``\n\n\nAnd vice versa. When the URL is changed manually or via back-forward buttons, the properties will be changed automatically.\n\n```js\nlocation.hash = '#!/baz/qux/';\n\nconsole.log(this.x, this.y); // ‘baz’, ‘qux’\n```\n\n## Property change listening\n\nAs usually you can listen property changes with [Matreshka#on](http://matreshka.io/#!Matreshka-on) method.\n\n```js\nthis.on('change:x', handler);\n```\n\n## Asterisk\n\nYou can pass a string which contain asterisks to ``initRouter`` if you don't need to synchronize some part of the path.\n\n```js\nthis.initRouter('/x/*/y');\n```\n\nIf the hash looks like ``#!/foo/bar/baz/``, then ``this.x = \"foo\"`` and ``this.y = \"baz\"``.\n\nThis feature is useful in cases when classes control different parts of the path.\n\n\n**class1.js**\n\n```js\nthis.initRouter('/x/*/');\n```\n\n**class2.js**\n\n```js\nthis.initRouter('/*/y/');\n```\n\n## Two things to remember\n\n**1.** If a property has truthy value then URL will be changed immediately after ``initRouter`` call.\n\n\n```js\nthis.x = 'foo';\n\nthis.initRouter('/x/y/');\n```\n\n**2.** If a property gets falsy value then all next listed values will get ``null`` as new value.\n\n```js\nthis.initRouter('/x/y/z/u/');\n\nthis.y = null; // makes this.z and this.u to be null as well\n```\n\nDon't worry about this feature. The idea is to get actual state of URL. It could be weird to get ``\"z\"`` with value ``\"foo\"`` in case of non-existing bound part of URL.\n\n## HTML5 History API\n\nThe plugin supports  HTML5 History as well. To initialize it you need to pass optional argument ``type`` with ``\"history\"`` value to the ``initRoute`` (by default ``type`` is ``\"hash\"``).\n\n```js\nthis.initRouter('x/y/z/', 'history');\n```\n\n\n## Custom objects support\n\nThe ``initRoute`` has static alternative which accepts custom object as the first argument. It works just the same.\n\n\n```js\nvar obj = {};\nMK.initRouter(obj, '/a/b/c/');\n\nobj.a = 'foo';\nobj.b = 'bar';\nobj.c = 'baz';\n```\n\n## Additional information\n\n### ``Matreshka.Router`` class\n\nThe core of Matreshka Router is powered by  ``Matreshka.Router`` class. It accepts only one argument - router type (``\"hash\"``, ``\"history\"`` or custom string).\n\nBy default, the plugin creates two instances of ``Matreshka.Router`` with types ``hash`` and ``history``. They are contained in ``Matreshka.Router.hash`` and ``Matreshka.Router.history``. The plugin uses lazy initialization so when you just attach the script onto webpage, the plugin does nothing.\n\nFor these two types of instances the singletone pattern is used. That means when you're trying to create another instance of ``hash`` routing via ``new Matreshka.Router('hash')``, the ``Matreshka.Router.hash`` will be returned instead of new instance creation. This logic centralizes URL handling, gives positive effect to the performance and doesn't allow to get collisions. Objects which are handled by ``initRouter`` just subscribe to the changes of needed type of router.\n\n\n\nCustom instances (non-hash and non-history) of ``Matreshka.Router`` can be created manually in case if you make code outside of the browser environment of you need to generate some URL for further usage. At this case changes of target properties don't affect on ``hash`` and don't call ``pushState``.\n\n### Properties\n\n``Matreshka.Router`` instances has 3 properties.\n\n- ``path`` - contains actual URL, eg ``/foo/bar/baz/``.\n- ``hashPath`` - contains actual URL and hashbang as a prefix, eg ``#!/foo/bar/baz/``\n- ``parts`` - contains an array of all parts of the path, eg ``[‘foo’, ‘bar’, ‘baz’]``.\n\nAll these properties are created using [linkProps](https://matreshka.io/#!Matreshka-linkProps), which means when you change one property, the others are changed automatically.\n\n```js\nMatreshka.Router.hash.path = '/yo/man/';\n```\n\nBy changing these properties you can call needed procedures (update the path, change subscribed objects etc.)\n\n### Methods\n\n- ``subscribe(object, route)`` - subscribes object to changes in properties above.\n- ``init()`` - used for lazy initialization in  ``subscribe`` method (no need to call it manually).\n\n```js\nvar customRouter = new Matreshka.Router(),\n\tobject = {\n\t\ta: 'foo',\n\t\tb: 'bar'\n\t};\n\ncustomRouter.subscribe(object, '/a/b/');\n\nconsole.log(customRouter.path); // /foo/bar/\n\n```\n",
  "readmeFilename": "README.md",
  "gitHead": "0ccccd87b9ae60a4866c311f3a422855d046ae39",
  "_id": "matreshka-router@0.0.5",
  "_shasum": "f9fe3ec13d06729a318fe74a2bb68f869ed76802",
  "_from": "matreshka-router@0.0.5"
}
